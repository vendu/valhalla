V0 INSTRUCTION SET ARCHITECTURE
-------------------------------

Register File
-------------

User Registers
--------------
- 16 general purpose registers R0-R15
- the R0-register, aka ZR, may be used to read all-zero input; writes to ZR
  shall be quietly ignored
- the R1-register is used for function return values as well as the first
  register argument for functions
- the R2-register provides  another return value for certain instructions, e.g.
  for returning the remainder when dividing integer values
- registers R2-R7 are used for the second to seventh function arguments
- registers R8-R15 are callee-save scratch registers

Name	Brief
----	-----
R0|RZ	zero-register; reads return 0, writes shall be ignored
R1	caller-save register #1, function argument #1, function return value
R2	function argument #2, function return high value
R3	function argument
R4	function argument
R5	function argument
R6	function argument
R7	function argument
R8	callee-save/scratch register #1
R9	scratch register
R10	scratch register
R11	scratch register
R12	scratch register
R13	scratch register
R14	scratch register
R15	scratch register

System Registers
----------------
- some of these registers may be accessed with special instructions
- some of the system registers cannot be accessed directly

ID	Name	Brief
--	----	-----
0	CR	control register
1	MFW	machine feature word
2	MSW	machine status word
3	PC	program counter/instruction pointer
4	FP	frame pointer to stack
5	SP	stack pointer
6	TR	task register; thread-local storage region address
7	IV	interrupt vector; table base address
8	IM	interrupt mask; 1-bits denote masked interrupts, default 0
9	PD	page-directory base address
10	CL	cacheline-bitmap base address
11	IO	I/O descriptor map page-address + flags
15	LN	link register, i.e. return address back to caller
Floating-Point Registers
------------------------
- V0 shall support IEEE754 32-bit single and 64-bit double precision floating-
  point numerical representations
- all floating-point registers are internally 64-bit to support both single
  and double precision floating point with a single set of registers

ID	Name	Brief
--	----	-----
0 	F0	floating-point register #0
1 	F1	floating-point register #1
2	F2	floating-point register #2
3 	F3	floating-point register #3
4 	F4	floating-point register #4
5 	F5	floating-point register #5
6 	F6	floating-point register #6
7 	F7	floating-point register #7
8 	F8	floating-point register #8
9 	F9	floating-point register #9
10	F10	floating-point register #10
11	F11	floating-point register #11
12	F12	floating-point register #12
13	F13	floating-point register #13
14	F14	floating-point register #14
15	F15	floating-point register #15

Addressing Modes
----------------

No Address
----------
- operands are stored in registers

Register Address
----------------
- base address is stored in a register

Immediate Address
-----------------
- address/offset follows opcode

Immediate Value
---------------
- operand is stored as a 32-bit value following the opcode

Direct Address
--------------
- immediate or register value is the canonical address

PC-Relative Address
-------------------
- PC (program counter) register is used as the base and the address is
  calculated so like

    adr = PC[ndx]

        or in AT&T assembly syntax

    $ndx(%pc)

  where ndx is an immediate 16-bit or 32-bit offset following the opcode

Indexed Address
---------------
- an indexed address takes the form of

    adr = reg1[reg2]	// indexed addressing with 2 registers

    	or

    adr = reg1[val]	// indexed address with a register and immediate value

    	or in AT&T assembly syntax

    %r2(%r1)

	and

    $val(%r1)

  where reg1/%r1 is the base address register and reg2/%r2/$val is the index.

Notes
-----
- a full memory address could be

  ptr[ofs] = 0xffU; // ptr is in a register, val or argument is ofs, so the
  	            // halfword (16-bit) address becomes ADR = %reg1 + ofs

Mode         Brief                           C               Assembly
----         -----                           -               --------
register     operand in a register           val = x;        str %r1, *%r2
immediate    operand follows opcode          val = CONST     $const
PC-relative  index in val or after opcode    goto label;     jmp 0xff(%pc)
indexed      index in val or after opcode    ptr[0xff] = x;  ldr 8(%r1), %r2

Mnemonics
---------
- I have chosen to use 3-letter mnemonics so far... instructions for the
  supplementary units such as floating-point would be 4 letters to emphasize
  the "external" processor/unit nature of them. for these instructions, I'm
  thinking of using the following initials in the mnemonics
  - P - fixed-point mathematics
  - F - floating-point, e.g. FADD, FMAC (multiply-and-add)
  - S - SIMD
  - M - multimedia (audio, graphics, ...)
  - V - vector
  - A - audio
  - D - DSP

Instruction Prefixes
--------------------

The COP-prefix marks coprocessor instructions
The MLK-prefix may be used to lock the memory bus for a single operation of
- NOT, AND, XOR, OR,INC, DEC, ADD, SDC, SUB, SBC, BTR, BTS, BTC, CAS

Fused Instructions
------------------
- I'm thinking of doing at least fused shift-and-add as well as multiply-and-
  add [the last typically for floating-point]

Call Conventions
----------------
- up to 7 register arguments are passed in R1..R7 in linear order
  - extra arguments are pushed to stack in reverse order
- registers R8..R15 are callee-saved scratch registers

Instruction Set Description
---------------------------

r1	register operand 1
r2	register operand 2
adr	memory address
r1r2	first register ID in low, last register ID in high 8 bits of operation
	parm-field

Opcode Table
------------

Operand Types
-------------
R	register operand
I	immediate [32-bit] operand following instruction opcode
V	immediate [12-bit] operand embedded in instruction opcode (parm-field)
ADR	memory address formed with one of the supported addressing-modes

Group	Unit	Code	Op	Flags	Brief
-----	----	----	--	-----	-----

Examples
--------

	not	RI1, R2		; R2 = ~RI1;
	neg	RI1, R2		; R2 = -RI1;

Flags
-----
AND	0x01
EXC	0x01
OR	0x02

LOGIC	0x01	0x00	NOT			bitwise inverse
LOGIC	0x01	0x01	AND	AND		bitwise logical AND
LOGIC	0x01	0x02	IOR	OR		bitwise logical OR
LOGIC	0x01	0x03	XOR	EXC|OR		bitwise logical XOR
---------------------------

Examples
--------

	shl	RV1, R2		; R2 <<= RV1
	sra	V, R1, R2	; R2 = (R2 >> V) + R1

Flags
-----
DIR	0x01
ARI	0x02
ROT	0x04
SAM	0x08

SHIFT	0x02	0x00	SHL			left shift
SHIFT	0x02	0x01	SHR	DIR		right shift
SHIFT	0x02	0x02	SAR	ARI		arithmetic right shift
SHIFT	0x02	0x04	ROL	ROT		left rotation
SHIFT	0x02	0x05	ROR	DIR|ROT		right rotation
SHIFT	0x02	0x06	SLA	SHA		shift left and accumulate
SHIFT	0x02	0x07	SRA	DIR|SHA		shift right and accumulate
SHIFT	0x02	0x08	SLM	SAM		shift left and mask
SHIFT	0x02	0x09	SRM	DIR|SAM 	shift right and mask
---------------------------

Examples
--------

	cmp	R1, R2		; R2 -= R1, set flags
	cmp	I1, R2		; R2 -= I1, set flags

Flags
-----
UNS	0x01
DEC	0x02
CF	0x02
ADD	0x04
CMP	0x04
SUB	0x08

ADDER	0x03	0x00	INC			increment by one
ADDER	0x03	0x01	INU	UNS		unsigned inscrement by one
ADDER	0x03	0x02	DEC	DEC		decrement by one
ADDER	0x03	0x03	DEU	UNS|DEC		unsigned decrement by one
ADDER	0x03	0x04	ADD	ADD		signed addition
ADDER	0x03	0x05	ADU	UNS|ADD		unsigned addition
ADDER	0x03	0x06	ADC	CF|ADD		signed addition with carry
ADDER	0x03	0x07	AUC	UNS|CF|ADD	unsigned addition with carry
ADDER	0x03	0x08	SUB	SUB		signed subtraction
ADDER	0x03	0x09	SBU	UNS|SUB		unsigned subtraction
ADDER	0x03	0x0a	SBC	CF|SUB		subtraction with carry
ADDER	0x03	0x0b	SUC	UNS|CF|SUB	unsigned subtraction w/ carry
ADDER	0x03	0x0c	CMP	CMP|SUB		comparison (subtract + set MSW)
ADDER	0x03	0x0d	CMU	UNS|CMP|SUB	unaifnws comparison
---------------------------

Examples
--------

	mul	R1, R2		; R2 *= R1
	mul	I1, R2		; R2 *= I1

Flags
-----
HI	0x02
REM	0x02
DIV	0x04
RPC	0x08

MULTI	0x04	0x00	MUL			signed multiplication
MULTI	0x04	0x01	MLU	UNS		unsigned multiplication
MULTI	0x04	0x02	MLH	HI		signed multiplication, high word
MULTI	0x04	0x03	MHU	UNS|HI		unsigned multiplication, high
MULTI	0x04	0x04	DIV	DIV		division
MULTI	0x04	0x05	DVU	UNS|DIV		unsigned division
MULTI	0x04	0x06	REM	REM|DIV		remainder
MULTI	0x04	0x07	RMU	UNS|REM|DIV	unsigned remainder
MULTI	0x04	0x08	RPS	RPC		signed inverse reciprocal
MULTI	0x04	0x09	RPU	UNS|RPC		unsigned inverse reciprocal
---------------------------

Examples
--------

	sexb	R1, R2		; R2 = sex(V = 8, R1)
	sexb	I1, R2		; R2 = sex(V = 8, I1)
	sexw	I1, R2		; R2 = sex(V = 16, I1)
	clz	RI1

Flags
-----
CNT	0x02
PAR	0x04
CRC	0x08
COND	0x08

BIT	0x05	0x00	SEX			sign extend
BIT	0x05	0x01	ZEX	UNS		zero extend
BIT	0x05	0x02	CLZ	CNT		count leading zeroes
BIT	0x05	0x03	HAM	ONE|CNT		Hamming weight/bit population
BIT	0x05	0x04	PAR	PAR		parity, 1 -> odd, 0 -> even
BIT	0x05	0x05	NEG	NEG		arithmetic negation
BIT	0x05	0x06	BCD	WR|BCD		convert to binary coded decimal
BIT	0x05	0x07	DCD	RD|WR|BCD RI	convert to binary
BIT	0x05	0x08	CRC	CRC	   	compute redundancy check
BIT	0x05	0x09	CST	RD|COND		conditional store
BIT	0x05	0x0a	CLD	WR|COND		conditional load
BIT	0x05	0x0b	SWP	SWP		swap byte-order
BIT	0x05	0x0c	HSH	HSH		32-bit hash
BIT	0x05	0x0d	HUN	RD|HSH		32-bit unhash (revert HSH)
BIT	0x05	0x0e	SET	SET		set bit
BIT	0x05	0x0f	CLR	(CLR|SET)	clear bit
---------------------------

Flags
-----
CL	0x04
BAR	0x08

MEM	0x06	0x00	LEA			load effective address
MEM	0x06	0x01	LDR	RD		load into register
MEM	0x06	0x02	STR	WR		store to memory
MEM	0x06	0x03	IPG	  		invalidate TLB-entry
MEM	0x06	0x04	CLR	CL		mark cacheline clear
MEM	0x06	0x05	CPF	RD|CL		prefetch cacheline
MEM	0x06	0x06	CFL	WR|CL		flush cacheline
MEM	0x06	0x08	BAR	BAR		full memory barrier
MEM	0x06	0x09	BRD	RD|BAR		memory read barrier
MEM	0x06	0x0a	BWR	WR|BAR		memory write barrier
MEM	0x06	0x0b	LFL	RD|MSW		read machine status word/flags
MEM	0x06	0x0c	SFL	WR|MSW		write machine status word/flags
MEM	0x06	0x0e	LDX	RD|SR		load system-register
MEM	0x06	0x0f	STX	WR|SR		store system-register
---------------------------

Flags
-----
RNG	0x02
FLG	0x04
FRM	0x04

STK	0x07	0x00	PSH			push register
STK	0x07	0x01	POP	RD		pop register
STK	0x07	0x02	PSM	RNG		push register range
STK	0x07	0x03	POM	RD|RNG		pop register range
STK	0x07	0x04	PSF 	FLG		push MSW
STK     0x07    0x05    POF     RD|FLG		pop MSW
STK	0x07	0x06	MKF	RNG|FRM		create call stack frame
---------------------------

Flags
-----
DBL	0x01
CLR	0x01
CAS	0x02
TST	0x04

ATOM	0x08	0x00	LNK			load-linked (lock cacheline)
ATOM	0x08	0x01	STC	SYN		store if cacheline not locked
ATOM	0x08	0x02	CAS	CAS		compare and swap
ATOM	0x08	0x03	CS2	DBL|CAS		compare and swap
ATOM	0x08	0x04	BTS	TST		bit test and set
ATOM	0x08	0x05	BTC	CLR|TST		bit test and clear
---------------------------

Flags
-----
NOT	0x01
REL	0x01
EQ	0x01
LT	0x04
ULT	0x08

FLOW	0x09	0x00	JMP			unconditional jump
FLOW	0x09	0x01	JMR	REL		PC-relative unconditional jump
FLOW	0x09	0x02	BEQ	EQ		branch if equal/zero
FLOW	0x09	0x03	BNE	NOT|EQ		branch if not equal/zero
FLOW	0x09	0x04	BLT	LT		branch if less than
FLOW	0x09	0x05	BGE	NOT|LT		branch if greater or equal
FLOW	0x09	0x06	BLE	EQ|LT		branch if less or equal
FLOW	0x09	0x07	BGT	NOT|EQ|LT	branch if greater
FLOW	0x09	0x08	ULT	ULT		unsigned less than
FLOW	0x09	0x09	UGE	NOT|ULT		branch if greater than or equal
FLOW	0x09	0x0a	ULE	EQ|ULT		unsigned greater than or equal
FLOW	0x09	0x0b	UGT	NOT|EQ|ULT	unsigned greater than
FLOW	0x09	0x0c	BCF	CF		branch if carry/borrow set
FLOW	0x09	0x0d	BNC	NOT|CF		branch if carry/borrow set
FLOW	0x09	0x0e	BOF	OF		branch on overflow
FLOW	0x09	0x0e	BNO	NOT|OF		branch if no overflow
---------------------------

Flags
-----
SUBR	0x01
TERM	0x01
FIN	0x02
SYS	0x02
RET	0x04
THR	0x08

SUBR	0x0a	0x00	BEG			begin subroutine
SUBR	0x0a	0x01	CSR	SUBR		call subroutine
SUBR	0x0a	0x02	FIN	FIN		finish subroutine
SUBR	0x0a	0x03	SYS	SYS|SUBR	enter system mode
SUBR	0x0a	0x04	RET	RET		return from subroutine
SUBR	0x0a	0x05	IRT	TERM|RET	return from interrupt routine
SUBR	0x0a	0x06	SRT	SYS|RET		return from system mode
SUBR	0x0a	0x08	THR	THR		launch new thread
SUBR	0x0a	0x09	THX	TERM|THR	terminate thread
SUBR	0x0a	0x0a	THS	SYS|THR		launch system thread
---------------------------

Flags
-----
ON	0x01
MASK	0x02
INT	0x04
EV	0x08

SYS	0x0b	0x00	CLI			disable interrupts (mask)
SYS	0x0b	0x01	STI	ON		enable all interrupts
SYS	0x0b	0x02	SIM	MASK		set interrupt mask
SYS	0x0b	0x03	LIM	ON|MASK		load interrupt mask
SYS	0x0b	0x04	INT	INT		send software interrupt
SYS	0x0b	0x05	SIV	ON|INT		set interrupt vector
SYS	0x0b	0x06	HLT	HLT		halt, wake up on interrupt
SYS	0x0b	0x07	RST	ON|HLT		reset
SYS	0x0b	0x08	WFE	EV		wait  for [cacheline] event
SYS	0x0b	0x09	SEV	ON|EV		signal [cacheline] event
---------------------------

Flags
-----
MAP	0x04

IO	0x0c	0x00	IOC			I/O-command
IO	0x0c	0x01	ILD	RD		load I/O-register
IO	0x0c	0x02	IST	WR		store I/O register
IO	0x0c	0x04	ILM	MAP		load I/O-descriptor map
IO	0x0c 	0x05	IRD	RD|MAP		read I/O-descriptor
IO	0x0c	0x06	IWR	WR|MAP	    	write I/O-descriptor

CST and CLD Instructions
------------------------

CST and CLD take a command ID in the xtra-field of the opcode. I will list the
commands so far.

CST/CLD Attributes
------------------

These attributes are used as postfixes for the STC and CLD instructions to
specify the condition for the operations.

eq	equal					ZF
ne	not equal				!ZF
zf	zero					ZF
nz	non-zero				!ZF
lt	less than				!ZF && !OF
le	less than or equal			ZF || !OF
gt	greater than 				!ZF || OF
ge	greater than or equal to		ZF || OF
cf	carry flag set	      			CF
nc	carry flag not set			!CF
of	overflow flag set			OF
no	overflow flag not set			!OF

Examples
--------

	cstle	R1, ADR2	; *ADR2 = R1 iff (!CF || ZF)
	cldeq	RI1, R2		; R2 = RI1 iff (ZF)

Val	Name		Description
---	----		-----------
0	ZF, EQ		ZF
1	NZ, NE		!ZF
2	OF		OF
3	NO		!OF
4	CF		CF
5	NC		!CF
6	LT		!ZF && !OF
7	LE		ZF || !OF
8	GT		!ZF && OF
9	GE		ZF || OF

IOC Instruction
---------------
- IOC has an 8-bit parm argument stating the command ID (argument RI1)
- IOC has address argument pointing to struct iodev (argument ADR2)
- size of IOC is 64-bit in 2 aligned 32-bit parcels

Standard I/O Devices
--------------------

ID	Name
--	----
0	V0_SYS
1	V0_TMR
2 	V0_KBD
3	V0_MOUSE
4	V0_VIDEO
5 	V0_NET
6	V0_MEDIA

Examples
--------

	ldr	$0, %r1			; bus ID
	ioc	$V0_BUS_PROBE, iodevtab	; probe bus, return count in %r1

	ioc	$V0_KBD_SETUP, iodevtab	; setup keyboard device, desc in %r1

Command IDs
-----------

Val	Description	Descriptor Members	Result in %r1
---	-----------	------------------	-------------
0	V0_BUS_PROBE	bus, size		struct iodev[size];
1	V0_BUS_INIT	bus, size		struct iodev[size];
2	V0_KBD_SETUP	bus, dev		uint16_t desc
3	V0_MOUSE_SETUP	bus, dev		uint16_t desc
4	V0_VIDEO_SETUP	bus, dev		uint16_t desc
5	V0_NET_SETUP	bus, dev		uint16_t desc
6	V0_MEDIA_SETUP	bus, dev		uint16_t desc
5	V0_DEV_PROBE	bus, dev		uint16_t desc
6	V0_DEV_INIT	bus, dev		uint16_t desc
7	V0_DEV_SETUP	bus, dev		uint16_t desc
8	V0_DEV_READ	bus, dev, base, size	uint32_t size
8	V0_DEV_REMOVE	bus, dev		uint32_t status
9	V0_DEV_MAP	bus, dev, base, size	uint32_t adr
10	V0_DEV_UNMAP	bus, dev, base, size	uint32_t status
11	V0_BLK_BUF	bus, dev, base, size	{ uint16_t desc, void *adr };
12	V0_BLK_XFER	bus, dev, base, size	{ uint16_t desc, void *adr };

Examples
--------

	ioc	$0, R1, R2	; R2 = ioc(V = PROBE, R1) ; R1 <= struct iodev *
		    		; R2 = device count
	ioc	$4, R1, R2	; R2 = ioc(V = SETUP, R1) ; R1 <= uint16_t
		    		; R2 = setup status
	ild	RI1		; Riom = RI1

I/O Registers
-------------

ID	Description
--	-----------
0x00	Interrupt Controller
0x01	Time-Stamp Counter
0x02	Timer Configuration
0x03	Real-Time Clock
0x04	Keyboard Configuration
0x05	Mouse Configuration
0x06	Display Configuration
0x07	Bus Configuration
0x08	Device Configuration
	- audio, video, HID, media, network, ...

I/O Commands
------------
