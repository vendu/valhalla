V0 INSTRUCTION SET ARCHITECTURE
-------------------------------

Register File
-------------

User Registers
--------------
- 16 general purpose registers R0-R15
- the R0-register, aka ZR, may be used to read all-zero input; writes to ZR
  shall be quietly ignored
- the R1-register is used for function return values as well as the first
  register argument for functions
- the R2-register provides  another return value for certain instructions, e.g.
  for returning the remainder when dividing integer values
- registers R2-R7 are used for the second to seventh function arguments
- registers R8-R15 are callee-save scratch registers

Name	Brief
----	-----
R0|RZ	zero-register; reads return 0, writes shall be ignored
R1	caller-save register #1, function argument #1, function return value
R2	function argument #2, function return high value
R3	function argument
R4	function argument
R5	function argument
R6	function argument
R7	function argument
R8	callee-save/scratch register #1
R9	scratch register
R10	scratch register
R11	scratch register
R12	scratch register
R13	scratch register
R14	scratch register
R15	scratch register

System Registers
----------------
- some of these registers may be accessed with special instructions
- some of the system registers cannot be accessed directly

ID	Name	Brief
--	----	-----
0	CR	control register
1	MFW	machine feature word
2	MSW	machine status word
3	PC	program counter/instruction pointer
4	FP	frame pointer to stack
5	SP	stack pointer
6	TR	task register; thread-local storage region address
7	IV	interrupt vector; table base address
8	IM	interrupt mask; 1-bits denote masked interrupts, default 0
9	PD	page-directory base address
10	CL	cacheline-bitmap base address
11	IO	I/O descriptor map page-address + flags
15	LN	link register, i.e. return address back to caller
Floating-Point Registers
------------------------
- V0 shall support IEEE754 32-bit single and 64-bit double precision floating-
  point numerical representations
- all floating-point registers are internally 64-bit to support both single
  and double precision floating point with a single set of registers

ID	Name	Brief
--	----	-----
0 	F0	floating-point register #0
1 	F1	floating-point register #1
2	F2	floating-point register #2
3 	F3	floating-point register #3
4 	F4	floating-point register #4
5 	F5	floating-point register #5
6 	F6	floating-point register #6
7 	F7	floating-point register #7
8 	F8	floating-point register #8
9 	F9	floating-point register #9
10	F10	floating-point register #10
11	F11	floating-point register #11
12	F12	floating-point register #12
13	F13	floating-point register #13
14	F14	floating-point register #14
15	F15	floating-point register #15

Addressing Modes
----------------

No Address
----------
- operands are stored in registers

Register Address
----------------
- base address is stored in a register

Immediate Address
-----------------
- address/offset follows opcode

Immediate Value
---------------
- operand is stored as a 32-bit value following the opcode

Direct Address
--------------
- immediate or register value is the canonical address

PC-Relative Address
-------------------
- PC (program counter) register is used as the base and the address is
  calculated so like

    adr = PC[ndx]

        or in AT&T assembly syntax

    $ndx(%pc)

  where ndx is an immediate 16-bit or 32-bit offset following the opcode

Indexed Address
---------------
- an indexed address takes the form of

    adr = reg1[reg2]	// indexed addressing with 2 registers

    	or

    adr = reg1[val]	// indexed address with a register and immediate value

    	or in AT&T assembly syntax

    %r2(%r1)

	and

    $val(%r1)

  where reg1/%r1 is the base address register and reg2/%r2/$val is the index.

Notes
-----
- a full memory address could be

  ptr[ofs] = 0xffU; // ptr is in a register, val or argument is ofs, so the
  	            // halfword (16-bit) address becomes ADR = %reg1 + ofs

Mode         Brief                           C               Assembly
----         -----                           -               --------
register     operand in a register           val = x;        str %r1, *%r2
immediate    operand follows opcode          val = CONST     $const
PC-relative  index in val or after opcode    goto label;     jmp 0xff(%pc)
indexed      index in val or after opcode    ptr[0xff] = x;  ldr 8(%r1), %r2

Mnemonics
---------
- I have chosen to use 3-letter mnemonics so far... instructions for the
  supplementary units such as floating-point would be 4 letters to emphasize
  the "external" processor/unit nature of them. for these instructions, I'm
  thinking of using the following initials in the mnemonics
  - P - fixed-point mathematics
  - F - floating-point, e.g. FADD, FMAC (multiply-and-add)
  - S - SIMD
  - M - multimedia (audio, graphics, ...)
  - V - vector
  - A - audio
  - D - DSP

Instruction Prefixes
--------------------

The COP-prefix marks coprocessor instructions
The MLK-prefix may be used to lock the memory bus for a single operation of
- NOT, AND, XOR, OR,INC, DEC, ADD, SDC, SUB, SBC, BTR, BTS, BTC, CAS

Fused Instructions
------------------
- I'm thinking of doing at least fused shift-and-add as well as multiply-and-
  add [the last typically for floating-point]

Call Conventions
----------------
- up to 7 register arguments are passed in R1..R7 in linear order
  - extra arguments are pushed to stack in reverse order
- registers R8..R15 are callee-saved scratch registers

Instruction Set Description
---------------------------

r1	register operand 1
r2	register operand 2
adr	memory address
r1r2	first register ID in low, last register ID in high 8 bits of operation
	parm-field

Opcode Table
------------

Group	Unit	Code	Op	Flags	Brief
-----	----	----	--	-----	-----

Syntax
------

	not	R1, R2		; R2 = not(R1)
	not	I1, R2		; R2 = not(I1)

LOGIC	0x01	0x00	NOT		bitwise inverse
LOGIC	0x01	0x01	AND	AND	bitwise logical AND
LOGIC	0x01	0x02	IOR	OR	bitwise logical OR
LOGIC	0x01	0x03	XOR	EXC|OR	bitwise logical XOR
LOGIC	0x01	0x04	NEG	NEG	negative
---------------------------

Syntax
------

	shl	RV1, R2		; R2 <<= RV1
	sra	V, R1, R2	; R2 = (R2 >> V) + R1

SHIFT	0x02	0x00	SHL		left shift
SHIFT	0x02	0x01	SHR	DIR	right shift
SHIFT	0x02	0x02	SAR	ARI	arithmetic right shift
SHIFT	0x02	0x04	ROL	ROT	left rotation
SHIFT	0x02	0x05	ROR	DIR|ROT	right rotation
SHIFT	0x02	0x08	SLA	SHA	shift left and accumulate
SHIFT	0x02	0x09	SRA	DIR|SHA	shift right and accumulate
SHIFT	0x02	0x0a	SLM	SAM	shift left and mask
SHIFT	0x02	0x0b	SRM	DIR|SAM shift right and mask
---------------------------

Syntax
------

	cmp	R1, R2		; R2 -= R1, set flags
	cmp	I1, R2		; R2 -= I1, set flags

ADD	0x03	0x00	ADD		signed addition
ADD	0x03	0x01	ADU	UNS	unsigned addition
ADD	0x03	0x02	ADC	FLG	signed addition with carry
ADD	0x03	0x03	AUC	UNS|FLG	unsigned addition with carry
ADD	0x03	0x04	INC	INC	increment by one
ADD	0x03	0x05	DEC	DEC|INC	decrement by one
ADD	0x03	0x08	SUB	SUB	signed subtraction
ADD	0x03	0x09	SBU	UNS|SUB	unsigned subtraction
ADD	0x03	0x0a	SBC	FLG|SUB	subtraction with carry
ADD	0x03	0x0b	SUC	UNS|FLG|SUB	unsigned subtraction w/ carry
ADD	0x03	0x0c	CMP	CMP|SUB	comparison (subtract + set MSW)
---------------------------

Syntax
------

	mul	R1, R2		; R2 *= R1
	mul	I1, R2		; R2 *= I1

MUL	0x04	0x00	MUL		RI, R	signed multiplication
MUL	0x04	0x01	MLU	UNS	RI, R	unsigned multiplication
MUL	0x04	0x02	MLH	HI	RI, R	signed multiplication, high word
MUL	0x04	0x03	MHU	UNS|HI	RI, R	unsigned multiplication, high
MUL	0x04	0x04	DIV	DIV	RI, R	division
MUL	0x04	0x05	DVU	UNS|DIV	RI, R	unsigned division
MUL	0x04	0x06	REM	REM|DIV	RI, R	remainder
MUL	0x04	0x07	RMU	UNS|REM|DIV RI, R unsigned remainder
MUL	0x04	0x08	RPS	RPC	RI, R	signed inverse reciprocal
MUL	0x04	0x09	RPU	UNS|RPC	RI, R	unsigned inverse reciprocal
---------------------------

Syntax
------

	sexb	R1, R2		; R2 = sex(V = 8, R1)
	sexb	I1, R2		; R2 = sex(V = 8, I1)
	sexw	I1, R2		; R2 = sex(V = 16, I1)
	cst

BIT	0x05	0x00	SEX		sign extend
BIT	0x05	0x01	ZEX	UNS	zero extend
BIT	0x05	0x02	CLZ	CNT	count leading zeroes
BIT	0x05	0x03	HAM	ONE|CNT	Hamming weight/bit population
BIT	0x05	0x04	PAR	PAR	parity check, 1 -> odd, 0 -> even
BIT	0x05	0x06	BCD	WR|BCD	convert to binary coded decimal
BIT	0x05	0x07	DCD	DCD|WR|BCD	convert to binary
BIT	0x05	0x08	CRC	CRC	compute redundancy check
BIT	0x05	0x09	CST	RD|COND	conditional store
BIT	0x05	0x0a	CLD	WR|COND	conditional load
BIT	0x055	0x0b	SWB		swap byte-order
BIT	0x05	0x0c	HSH	HSH	32-bit hash
BIT	0x05	0x0d	UNH	RD|HSH	32-bit unhash (revert HSH)
---------------------------
MEM	0x06	0x00	LEA		A, R	load effective address
MEM	0x06	0x01	LDR	RD	RIA, R	load into register
MEM	0x06	0x02	STR	WR	RI, A	store to memory
MEM	0x06	0x03	IPG	  	A	invalidate TLB-entry
MEM	0x06	0x04	CLR	CL	A	mark cacheline clear
MEM	0x06	0x05	CPF	RD|CL	A	prefetch cacheline
MEM	0x06	0x06	CFL	WR|CL	A	flush cacheline
MEM	0x06	0x08	BAR	BAR		full memory barrier
MEM	0x06	0x09	BRD	RD|BAR		memory read barrier
MEM	0x06	0x0a	BWR	WR|BAR		memory write barrier
MEM	0x06	0x0b	RFL	RD|MSW	R	read machine status word/flags
MEM	0x06	0x0c	WFL	WR|MSW	RI	write machine status word/flags
---------------------------
STK	0x07	0x00	PSH		RI	push register
STK	0x07	0x01	POP	RD	R	pop register
STK	0x07	0x02	PSM	N	R1R2	push register range
STK	0x07	0x03	POM	RD|N	R1R2	pop register range
STK	0x07	0x04	PSF	MSW		push MSW
STK     0x07    0x05    POF     RD|MSW  R       pop MSW
---------------------------
ATOM	0x08	0x00	LNK		RIA, R	load-linked (lock cacheline)
ATOM	0x08	0x01	STC	SYN	R1R2, A	store if cacheline not locked
ATOM	0x08	0x02	CAS	CAS	R, R, A	compare and swap
ATOM	0x08	0x03	CS2	DBL|CAS	R, R, A	compare and swap
ATOM	0x08	0x04	BTS	BT	RI, A	bit test and set
ATOM	0x08	0x05	BTC	CLR|BT	RI, A	bit test and clear
---------------------------
FLOW	0x09	0x00	JMP		RIA	unconditional jump
FLOW	0x09	0x01	BEQ	EQ	RIA	branch if equal/zero
FLOW	0x09	0x02	BNE	NE	RIA	branch if not equal/zero
FLOW	0x09	0x04	BLT	LT	RIA	branch if less than
FLOW	0x09	0x05	BUL	UNS|LT	RIA	unsigned branch if less than
FLOW	0x09	0x06	BGT	GT	RIA	branch if greater than
FLOW	0x09	0x07	BUG	UNS|GT	RIA	unsigned branch if greater than
FLOW	0x09	0x08	BFL	BFL	RIA	branch if carry/borrow set
FLOW	0x09	0x09	BOF	BOF|BFL	RIA	branch on overflow
---------------------------
SUB	0x0a	0x00	BEG			begin subroutine
SUB	0x0a	0x01	FIN	FIN		finish subroutine
SUB	0x0a	0x02	CSR	SUB		call subroutine
SUB	0x0a	0x03	SYS	SYS|SUB		enter system mode
SUB	0x0a	0x04	RET	RET		return from subroutine
SUB	0x0a	0x05	IRT	TERM|RET	return from interrupt routine
SUB	0x0a	0x06	SRT	SYS|RET		return from system mode
SUB	0x0a	0x08	THR	THR		launch new thread
SUB	0x0a	0x09	THX	TERM|THR	terminate thread
SUB	0x0a	0x0a	THS	SYS|THR		launch system thread
---------------------------
SYS	0x0b	0x00	CLI			disable interrupts (mask)
SYS	0x0b	0x01	STI			enable all interrupts
SYS	0x0b	0x02	ISM	MSK	RI	set interrupt mask
SYS	0x0b	0x03	ILM	ON|MSK	R	load interrupt mask
SYS	0x0b	0x04	INT	INT	RI8	send software interrupt
SYS	0x0b	0x06	HLT	HLT		halt, wake up on interrupt
SYS	0x0b	0x07	RST	RET|HLT	A	reset
SYS	0x0b	0x08	WFE	EV	A	wait  for [cacheline] event
SYS	0x0b	0x09	SEV	SEND|EV	A	signal [cacheline] event
---------------------------
IO	0x0c 	0x00	IOP		RI, A	set I/O permissions
IO	0x0c	0x01	IOQ	RD	A, R	query I/O permissions
IO	0x0c	0x02	IWC	IR	RI, R	write I/O register
IO	0x0c	0x03	IRC	RD|IR	RI, R	read I/O register
IO	0x0c	0x04	IOC	CMD	RI, A	I/O command
IO	0x0c	0x05	ILD	MAP|CMD	RI, A	load I/O-descriptor map (limit)

CST and CLD Instructions
------------------------

CST and CLD take a command ID in the xtra-field of the opcode. I will list the
commands so far.

CST/CLD Commands
----------------

Syntax
------

	cstle	R1, RI2
	cldeq	I1, R2		; R2 = I1 iff ZF is set in MSW

Val	Name		Description
---	----		-----------
0	ZF		ZF
1	NZ		!ZF
2	OF		OF
3	NO		!OF
4	CF		CF
5	NC		!CF
6	LT		!ZF && !CF
7	LE		ZF || !CF
8	EQ		ZF
9	NE		!ZF
10	GT		!ZF && CF
11	GE		ZF || CF

IOC Instruction
---------------
- IOC has an 8-bit parm argument stating the command ID (argument #1)
- IOC has address argument pointing to struct iodev (argument #2)
- size of IOC is 48 or 64 bytes depending on necessity of alignment

Command IDs
-----------

Val	Description	Descriptor Members	Result
---	-----------	------------------	------
0	bus probe	bus			struct iodev[V0_IO_MAX_DEVS];
1	bus init	bus			(struct iodev *ptr, size_t n);
2	device probe	bus, dev		struct iodev[V0_IO_MAX_DEVS];
3	device init	bus, dev		(uint16_t desc);
4	device setup	bus, dev		(uint16_t desc);
5	device remove	bus, dev		(uint16_t desc);
6	device map	bus, dev, base, size	(uint16_t desc, void *adr);
7	device unmap	bus, dev, base, size	(uint16_t desc);
8	block buffer	bus, dev, base, size	(uint16_t desc, void *adr);
9	block transfer	bus, dev, base, size	(uint16_t desc, void *adr);

Syntax
------

	ioc	$0, R1, R2	; R2 = ioc(V = PROBE, R1) ; R1 <= struct iodev *
		    		; R2 = device count
	ioc	$4, R1, R2	; R2 = ioc(V = SETUP, R1) ; R1 <= uint16_t
		    		; R2 = setup status
	ild	RI1		; Riom = RI1

I/O Registers
-------------

ID	Description
--	-----------
0x00	Interrupt Controller
0x01	Time-Stamp Counter
0x02	Timer Configuration
0x03	Real-Time Clock
0x04	Keyboard Configuration
0x05	Mouse Configuration
0x06	Display Configuration
0x07	Bus Configuration
0x08	Device Configuration
	- audio, video, HID, media, network, ...

I/O Commands
------------
